name: Deploy project (dev | staging | prod)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      destroy_after_deploy:
        description: 'Destroy resources after deployment (for testing)'
        required: false
        default: false
        type: boolean

env:
  PROJECT_NAME: ${{ github.event.inputs.environment || 'devopsthehardway' }}
  LOCATION: "westeurope"
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  ARM_USE_OIDC: true

jobs:
  deploy:
    name: ðŸš€ Deploy Infrastructure and Application
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      pull-requests: write
    
    steps:
    - name: ðŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ðŸ” Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ env.ARM_CLIENT_ID }}
        tenant-id: ${{ env.ARM_TENANT_ID }}
        subscription-id: ${{ env.ARM_SUBSCRIPTION_ID }}

    - name: ðŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.9.8
        terraform_wrapper: false

    - name: ðŸ³ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: â˜¸ï¸ Setup kubectl
      uses: azure/setup-kubectl@v4
      with:
        version: 'latest'

    - name: âš™ï¸ Setup Helm
      uses: azure/setup-helm@v4
      with:
        version: 'latest'

    - name: ðŸ—ï¸ Create Terraform State Storage
      run: |
        TERRAFORM_RG="rg-tfstate-${PROJECT_NAME}"
        STORAGE_ACCOUNT="sametyistfstate${PROJECT_NAME}"
        
        # Create resource group for terraform state
        az group create --name "$TERRAFORM_RG" --location "$LOCATION"
        
        # Create storage account
        az storage account create \
          --name "$STORAGE_ACCOUNT" \
          --resource-group "$TERRAFORM_RG" \
          --location "$LOCATION" \
          --sku Standard_LRS \
          --encryption-services blob \
          --allow-blob-public-access false \
          --allow-shared-key-access false \
          
        # Create storage container
        az storage container create \
          --name tfstate \
          --account-name "$STORAGE_ACCOUNT" \
          --auth-mode login

    # - name: ðŸ—ï¸ Create Azure AD Group for AKS
    #   run: |
    #     GROUP_NAME="gr-admins-aks-${PROJECT_NAME}"
        
    #     # Check if group exists
    #     GROUP_ID=$(az ad group list --filter "displayName eq '${GROUP_NAME}'" --query "[0].id" -o tsv)
        
    #     if [ -z "$GROUP_ID" ] || [ "$GROUP_ID" = "null" ]; then
    #       echo "Creating new AD group: $GROUP_NAME"
    #       GROUP_ID=$(az ad group create \
    #         --display-name "${GROUP_NAME}" \
    #         --mail-nickname "${GROUP_NAME}" \
    #         --query id -o tsv)
    #     fi
        
    #     echo "AKS_ADMINS_GROUP_ID=$GROUP_ID" >> $GITHUB_ENV
    #     echo "Azure AD Group ID: $GROUP_ID"
    #     # Environment variables written to $GITHUB_ENV are only available for later steps in the same job, not across jobs.
    #     # Use this when you need to dynamically set env vars (e.g., values generated at runtime).
    #     # For secrets or static vars, its better to use env: or ${{ secrets.NAME }}.

    - name: ðŸ—ï¸ Deploy ACR
      run: |
        cd 2-Terraform/1-acr
        
        # Update terraform.tfvars
        cat > terraform.tfvars << EOF
        name     = "$PROJECT_NAME"
        location = "$LOCATION"
        
        tags = {
          "Purpose"     = "azure-devops-hardway"
          "Environment" = "${{ github.event.inputs.environment || 'dev' }}"
          "DeployedBy"  = "GitHub-Actions"
          "Project"     = "$PROJECT_NAME"
        }
        EOF
        
        terraform init \
          -backend-config="resource_group_name=rg-tfstate-${PROJECT_NAME}" \
          -backend-config="storage_account_name=sametyistfstate${PROJECT_NAME}" \
          -backend-config="container_name=tfstate" \
          -backend-config="key=acr.tfstate" \
          -backend-config="use_azuread_auth=true"
        
        terraform plan -out=tfplan -var-file="terraform.tfvars"
        terraform apply tfplan

    - name: ðŸ—ï¸ Deploy VNET
      run: |
        cd 2-Terraform/2-vnet
        
        # Update terraform.tfvars
        cat > terraform.tfvars << EOF
        name                      = "$PROJECT_NAME"
        location                  = "$LOCATION"
        network_address_space     = "192.168.0.0/16"
        aks_subnet_address_name   = "aks"
        aks_subnet_address_prefix = "192.168.0.0/22"
        subnet_address_name       = "appgw"
        subnet_address_prefix     = "192.168.4.0/24"
        
        tags = {
          "Purpose"     = "azure-devops-hardway"
          "Environment" = "${{ github.event.inputs.environment || 'dev' }}"
          "DeployedBy"  = "GitHub-Actions"
          "Project"     = "$PROJECT_NAME"
        }
        EOF
        
        terraform init \
          -backend-config="resource_group_name=rg-tfstate-${PROJECT_NAME}" \
          -backend-config="storage_account_name=sametyistfstate${PROJECT_NAME}" \
          -backend-config="container_name=tfstate" \
          -backend-config="key=vnet.tfstate" \
          -backend-config="use_azuread_auth=true"
        
        terraform plan -out=tfplan -var-file="terraform.tfvars"
        terraform apply tfplan

    - name: ðŸ—ï¸ Deploy Log Analytics
      run: |
        cd 2-Terraform/3-log-analytics
        
        # Update terraform.tfvars
        cat > terraform.tfvars << EOF
        name     = "$PROJECT_NAME"
        location = "$LOCATION"
        
        tags = {
          "Purpose"     = "azure-devops-hardway"
          "Environment" = "${{ github.event.inputs.environment || 'dev' }}"
          "DeployedBy"  = "GitHub-Actions"
          "Project"     = "$PROJECT_NAME"
        }
        EOF
        
        terraform init \
          -backend-config="resource_group_name=rg-tfstate-${PROJECT_NAME}" \
          -backend-config="storage_account_name=sametyistfstate${PROJECT_NAME}" \
          -backend-config="container_name=tfstate" \
          -backend-config="key=law.tfstate" \
          -backend-config="use_azuread_auth=true"
        
        terraform plan -out=tfplan -var-file="terraform.tfvars"
        terraform apply tfplan

    - name: ðŸ—ï¸ Deploy AKS Cluster
      run: |
        cd 2-Terraform/4-aks
        
        # Generate SSH key for AKS
        ssh-keygen -t rsa -b 4096 -f ~/.ssh/aks_key -N "" -C "github-actions"
        SSH_PUBLIC_KEY=$(cat ~/.ssh/aks_key.pub)
        
        # Update terraform.tfvars
        cat > terraform.tfvars << EOF
        name     = "$PROJECT_NAME"
        location = "$LOCATION"
        
        kubernetes_version         = "1.33"
        agent_count                = 2
        vm_size                    = "Standard_DS2_v2"
        ssh_public_key             = "$SSH_PUBLIC_KEY"
        aks_admins_group_object_id = "$AKS_ADMINS_GROUP_ID"
        
        tags = {
          "Purpose"     = "azure-devops-hardway"
          "Environment" = "${{ github.event.inputs.environment || 'dev' }}"
          "DeployedBy"  = "GitHub-Actions"
          "Project"     = "$PROJECT_NAME"
        }
        EOF
        
        terraform init \
          -backend-config="resource_group_name=rg-tfstate-${PROJECT_NAME}" \
          -backend-config="storage_account_name=sametyistfstate${PROJECT_NAME}" \
          -backend-config="container_name=tfstate" \
          -backend-config="key=aks.tfstate" \
          -backend-config="use_azuread_auth=true"
        
        terraform plan -out=tfplan -var-file="terraform.tfvars"
        terraform apply tfplan
        
        # Get AKS credentials
        az aks get-credentials \
          --resource-group "$rg-{PROJECT_NAME}" \
          --name "$aks-{PROJECT_NAME}" \
          --overwrite-existing

    - name: ðŸ³ Build and Push Docker Image
      run: |
        cd 3-Docker
        
        # Login to ACR
        az acr login --name "$azurecr{PROJECT_NAME}"
        
        # Build and push image
        docker build --platform linux/amd64 \
          -t "${PROJECT_NAME}.azurecr.io/Nebulanomi:v2" .
        
        docker push "${PROJECT_NAME}.azurecr.io/Nebulanomi:v2"

    - name: â˜¸ï¸ Deploy Application to Kubernetes
      run: |
        cd 4-kubernetes
        
        # Update deployment.yml with correct image
        sed -i "s/azurecrdevopsthehardway.azurecr.io/${PROJECT_NAME}.azurecr.io/g" deployment.yml
        
        # Deploy application
        kubectl apply -f deployment.yml
        
        # Wait for deployment to be ready
        kubectl wait --for=condition=available --timeout=300s deployment/nebulanomi -n azure-app-system

    - name: ðŸŒ Install ALB Controller
      run: |
        cd 4-kubernetes
        
        # Update script with correct resource names
        sed -i "s/rg-devopsthehardway/rg-${PROJECT_NAME}/g" other-scripts/1-alb-controller-install-k8s.sh
        
        # Install ALB Controller
        chmod +x scripts/1-alb-controller-install-k8s.sh
        ./scripts/1-alb-controller-install-k8s.sh
        
        # Wait for ALB Controller to be ready
        kubectl wait --for=condition=available --timeout=300s deployment/alb-controller -n azure-alb-system

    - name: ðŸŒ Create Gateway Resources
      run: |
        cd 4-kubernetes
        
        # Update script with correct resource names
        sed -i "s/rg-devopsthehardway/rg-${PROJECT_NAME}/g" other-scripts/2-gateway-api-resources.sh
        sed -i "s/devopsthehardway-alb/alb-${PROJECT_NAME}/g" other-scripts/2-gateway-api-resources.sh
      
        # Create gateway resources
        chmod +x scripts/2-gateway-api-resources.sh
        ./scripts/2-gateway-api-resources.sh
        
        # Wait for gateway to get IP
        sleep 60

    - name: ðŸ§ª Test Application
      run: |
        # Get gateway IP
        GATEWAY_IP=$(kubectl get gateway gateway-01 -n azure-app-system -o jsonpath='{.status.addresses[0].value}' 2>/dev/null || echo "")
        
        if [ -n "$GATEWAY_IP" ]; then
          echo "ðŸŒ Application URL: http://$GATEWAY_IP"
          
          # Test application
          for i in {1..10}; do
            if curl -s -f "http://$GATEWAY_IP" > /dev/null; then
              echo "âœ… Application is responding correctly!"
              break
            else
              echo "â³ Waiting for application to be ready (attempt $i/10)..."
              sleep 30
            fi
          done
        else
          echo "âš ï¸ Gateway IP not yet available"
          kubectl get gateway gateway-01 -n azure-app-system -o yaml
        fi

    - name: ðŸ“Š Deployment Summary
      run: |
        echo "## ðŸŽ‰ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“‹ Resources Created:" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Azure Container Registry" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Virtual Network with subnets" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Log Analytics workspace" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… AKS cluster with auto-scaling" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Docker image built and pushed" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Application deployed to Kubernetes" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… ALB Controller and Gateway configured" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        GATEWAY_IP=$(kubectl get gateway gateway-01 -n azure-app-system -o jsonpath='{.status.addresses[0].value}' 2>/dev/null || echo "Pending")
        echo "### ðŸŒ Application Access:" >> $GITHUB_STEP_SUMMARY
        echo "**URL:** http://$GATEWAY_IP" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ—ï¸ Project Details:" >> $GITHUB_STEP_SUMMARY
        echo "- **Project Name:** $PROJECT_NAME" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment:** ${{ github.event.inputs.environment || 'dev' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Location:** $LOCATION" >> $GITHUB_STEP_SUMMARY
        echo "- **Kubernetes Version:** 1.33" >> $GITHUB_STEP_SUMMARY

  cleanup:
    name: ðŸ—‘ï¸ Cleanup Resources (if requested)
    runs-on: ubuntu-latest
    needs: deploy
    if: ${{ github.event.inputs.destroy_after_deploy == 'true' }}
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: ðŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ðŸ” Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: ðŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.9.8
        terraform_wrapper: false

    - name: â˜¸ï¸ Setup kubectl
      uses: azure/setup-kubectl@v4
      with:
        version: 'latest'

    - name: âš™ï¸ Setup Helm
      uses: azure/setup-helm@v4
      with:
        version: 'latest'

    - name: ðŸ—‘ï¸ Run Cleanup Script
      run: |
        # Make cleanup script executable
        chmod +x scripts/cleanup-all.sh
        
        # Set environment variables for cleanup
        export PROJECT_NAME="${PROJECT_NAME}"
        export LOCATION="${LOCATION}"
        
        # Run cleanup with auto-confirmation
        echo "DELETE" | ./scripts/cleanup-all.sh

    - name: ðŸ“Š Cleanup Summary
      run: |
        echo "## ðŸ—‘ï¸ Cleanup Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“‹ Resources Cleaned Up:" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ—‘ï¸ Kubernetes deployments and services" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ—‘ï¸ ALB Controller and Gateway resources" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ—‘ï¸ AKS cluster and node pools" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ—‘ï¸ Virtual Network and subnets" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ—‘ï¸ Log Analytics workspace" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ—‘ï¸ Azure Container Registry" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ—‘ï¸ Resource groups (deletion in progress)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Note:** Resource group deletions are running in the background and may take 10-15 minutes to complete."
